
// C++编程规范

// 头文件保护
// 所有的头文件都应该使用#define防止头文件被多重包含(multiple inclusion)
// 命名格式为<PROJECT>_<PATH>_<FILE>_H_,为保证唯一性，头文件的命名应基于
// 所在项目原代码树的全路径

// 头文件依赖
// 使用前置声明（forward declarations）尽量减少.h 文件中#include的数量。 
// 当一个头文件被包含的同时也引入了一项新的依赖（dependency），只要该头
// 文件被修改，代码就要重新编译。如果你的头文件包含了其他头文件，这些头
// 文件的任何改变也将导致那些包含了你的头文件的代码重新编译。因此，我们
// 应该尽量少的包含头文件，尤其是那些包含在其他头文件中的。使用前置声明
// 可以显著减少需要包含的头文件数量。

// 在头文件中做到使用类Foo而无需访问类的定义
// 1)将数据成员类型声明为Foo*或Foo&
// 2)参数、返回值类型为Foo的函数只是声明(但不定义实现)
// 3)静态数据成员的类型可以被声明为Foo,因为静态数据成员的定义在类定义之外
// 另一方面，如果你的类是Foo的子类，或者含有类型为Foo的非静态数据成员，
// 则必须包含头文件，cpp文件无论如何都需要所使用类的定义部分，肯定会包含
// 若干头文件。注：能依赖声明就不要依赖定义。

// 内联函数
// 一个比较得当的处理规则是，不要内联超过10行的函数。对于析构函数应慎重
// 对待,析构函数往往比其表面看起来要长，因为有一些隐式成员和基类析构函数
// (如果有的话)被调用。
// 另一有用的处理规则：内联那些包含循环或switch语句的函数是得不偿失的，
// 除非在大多数情况下，这些循环或switch语句从不执行。

// 重要的是，虚函数和递归函数即使被声明为内联的也不一定就是内联函数。通常，
// 递归函数不应该被声明为内联的（译者注：递归调用堆栈的展开并不像循环那么
// 简单，比如递归层数在编译时可能是未知的，大多数编译器都不支持内联递归函数）
// 析构函数内联的主要原因是其定义在类的定义中，为了方便抑或是对其行为给出文档。

// 函数的参数顺序 输入参数在前，输出参数在后

// 包含文件的名称及次序，将包含次序标准化可增强可读性、避免隐藏依赖
// (hidden dependencies，注：隐藏依赖主要是指包含的文件编译),次序如下:
// C库、C++库、其他库的.h、项目内的.h