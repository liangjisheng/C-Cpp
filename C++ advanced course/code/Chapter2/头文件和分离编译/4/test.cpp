
#include <iostream>
#include "test.h"


// 关键是：在分离式编译的环境下，编译器编译某一个.cpp文件时并
// 不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时
// 它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，
// 但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来，
// 所以，当编译器只看到模板的声明时，它不能实例化该模板，只能
// 创建一个具有外部连接的符号并期待连接器能够将符号的地址决议
// 出来。然而当实现该模板的.cpp文件中没有用到模板的实例时，
// 编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例
// 的二进制代码，于是连接器也黔驴技穷了

template<class T>
void A<T>::f() { std::cout << "hello" << std::endl; }		// 实现

// 当实例化一个模板，并调用其中定义的函数时，cpp文件编译生成的obj
// 中的符号导出表中就有相应的符号，链接的时候就能找到相应的实现
void f1()
{
	A<int> a;
	a.f();
}