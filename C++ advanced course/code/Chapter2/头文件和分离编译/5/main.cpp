
// 在这个例子中，test.cpp和main.cpp各自被编译成不同的.obj文件
// (姑且命名为test.obj和main.obj)，在main.cpp中，调用了f函数，
// 然而当编译器编译main.cpp时，它所仅仅知道的只是main.cpp中
// 所包含的test.h文件中的一个关于void f();的声明，所以，编译器将
// 这里的f看作外部连接类型，即认为它的函数实现代码在另一个.obj
// 文件中，本例也就是test.obj，也就是说，main.obj中实际没有关于
// f函数的哪怕一行二进制代码，而这些代码实际存在于test.cpp所编译
// 成的test.obj中。在main.obj中对f的调用只会生成一行call指令，
// 像这样：call f [C++中这个名字当然是经过mangling[处理]过的]

// 在编译时，这个call指令显然是错误的，因为main.obj中并无一行f的
// 实现代码。那怎么办呢？这就是连接器的任务，连接器负责在其它的
// .obj中（本例为test.obj）寻找f的实现代码，找到以后将call f这个
// 指令的调用地址换成实际的f的函数进入点地址。需要注意的是：
// 连接器实际上将工程里的.obj“连接”成了一个.exe文件，而它最关键
// 的任务就是上面说的，寻找一个外部连接符号在另一个.obj中的地址，
// 然后替换原来的“虚假”地址。

// 这个过程如果说的更深入就是：
// call f这行指令其实并不是这样的，它实际上是所谓的stub，也就是一个
// jmp 0xABCDEF。这个地址可能是任意的，然而关键是这个地址上有一行
// 指令来进行真正的call f动作。也就是说，这个.obj文件里面所有对f的
// 调用都jmp向同一个地址，在后者那儿才真正”call”f。这样做的好处
// 就是连接器修改地址时只要对后者的call XXX地址作改动就行了。但是，
// 连接器是如何找到f的实际地址的呢（在本例中这处于test.obj中），
// 因为.obj与.exe的格式是一样的，在这样的文件中有一个符号导入表和
// 符号导出表（import table和export table）其中将所有符号和它们的
// 地址关联起来。这样连接器只要在test.obj的符号导出表中寻找符号f
// （当然C++对f作了mangling）的地址就行了，然后作一些偏移量处理后
// (因为是将两个.obj文件合并,当然地址会有一定的偏移,这个连接器清楚)
// 写入main.obj中的符号导入表中f所占有的那一项即可

#include <iostream>

// 包含test头文件，相当于在main.cpp这个文件域中声明了f这个函数
// 所以main函数里可以直接调用f，可以将f声明在这个文件域中，也可以将
// f声明在main函数里，只虚将下面的头文件注释掉，并在main函数的开头
// 声明f就可以,void f();或者将#include "test.h"加到main函数里面
// #include "test.h"

void f1()
{
	// 如果此时f1想调用f，必须再次声明f
	void f();
	f();
}

int main()
{
#include "test.h"
	f();

	system("pause");
	return 0;
}